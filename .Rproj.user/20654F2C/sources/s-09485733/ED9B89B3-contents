# ------ EJEMPLO 2: Tasa de desempleo --------

# Para el último ejemplo vamos a trabajar con la serie de la Tasa de desempleo mensual para Estados Unidos de 1959 a 2012.
# Este indicador económico mide el porcentaje de la población económicamente activa que se encuentra desempleada. Para el caso 
# estadounidense, se toma a la población económicamente activa (labor force) como todas aquellas personas de 16 o más años, que 
# en alguno de los 50 estados, se encuentren en capacidad de trabajar. La forma de calcularlo es: 
# (población desocupada/población económicamente activa)*100.

# Fuente: https://fred.stlouisfed.org/series/UNRATE (Tomado de la FRED de la Reserva Federal de St Louis)

#---- PASO 1- IDENTIFICACIÓN tasa de desempleo ----

# Se cargan las series de tiempo
base_unem <- read_excel(file.choose()) #UNRATE
view(base_unem)

UNRATE = ts(base_unem$UNRATE, start = c(1959,11), frequency = 12) # La serie empieza en noviembre de 1959 y es una serie mensual.

# Visualización de los datos
View(UNRATE)  

# Crear un objeto tipo xts
UNRATE_xts = xts(base_unem$UNRATE, 
                 order.by = base_unem$observation_date) # Importar como un objeto xts

View(UNRATE_xts)

## Graficamos la serie con la funcion del paquete stats de R
x11()   
plot.ts(UNRATE, xlab="",ylab="", main="Tasa de desempleo mensual EE.UU (1959-2012)",lty=1, lwd=2, col="purple")

# Para el objeto xts
x11()
plot(UNRATE_xts, main = "Tasa de desempleo mensual EE.UU (1959-2012)", ylab  = "UNRATE")

#Vamos a graficar la ACF y PACF de la serie en nivel.
lags=24
par(mfrow=c(1,2))
acf(UNRATE,lag.max=lags,plot=T,lwd=2,xlab='',main='ACF de la Tasa de desempleo') 
pacf(UNRATE,lag.max=lags,plot=T,lwd=2,xlab='',main='PACF de la Tasa de desempleo')

# La grafica de la serie no muestra el comportamiento tipico de una serie estacionaria, puesto que si bien se podria
# afirmar que su varianza es estable, lo mismo no parece ser cierto para su media. Igualmente, en la grafica FAC presenta 
# un decaimiento a cero pero este es muy lento, propio de un proceso altamente persistente. Por tanto, la 
# serie no es estacionaria y se hace necesario realizar las transformaciones explicadas más arriba.

# Prueba de Augment Dickey Fuller

# La ADF es una prueba estándar y muy utilizada para saber si una serie de tiempo tiene al menos una raíz unitaria o no.
# La presencia de una raíz unaitaria hace que la serie de tiempo estudiada no sea estacionaria. A la hora de utilizar
# la metodología Box Jenkins para series ARIMA es importante trabajar con una serie estacionaria o con una una serie
# no estacionaria debidamente diferenciada para que la serie diferenciada (pueden ser varias diferencias) sea
# estacionaria y de ahí la importancia de la pruba ADF para la identificación de series estacionarias

# Prueba con trend

adf.trend_unrate= ur.df(UNRATE, type="trend", selectlags = "AIC")
summary(adf.trend_unrate)

# Prueba con drift

adf.drift_unrate= ur.df(UNRATE, type="drift", selectlags = "AIC")
summary(adf.drift_unrate) 

# Conclusión Prueba de Dickey Fuller: 

# 1. La serie no es estacionaria, por lo que hay que diferenciarla para 
# eliminar posibles raíces unitarias.

# Nota: presencia de raíz unitaria es lo mismo que la existencia de una tendencia 
#       estócástica en la serie. Solución: Diferenciar la serie.

#Vamos a analizar las estadísticas descriptivas de la serie en primera diferencia. 
describe(d.UNRATE) #La media es igual a cero, por eso no se incluye un intercepto en el modelo. 

## Vamos a diferenciar la serie para # eliminar su tendencia, por medio de diff(serie_original):

d.UNRATE = diff(UNRATE) # serie diferenciada

# Vamos a graficar ahora el nivel (serie original) y la variación (serie diferenciada) de la tasa de desempleo.

x11()
par(mfrow=c(2,1))
plot.ts(UNRATE, xlab="",ylab="", main="Tasa de desempleo en nivel 1959-2012",
        lty=1, lwd=2, col="blue")
plot.ts(d.UNRATE, xlab="",ylab="", main="Variación de la Tasa de desempleo 1959-2012",lty=1,
        lwd=2, col="red")

# Igualmente graficamos la ACF y la PACF para la variación de la tasa de desempleo

x11()
lags=30
par(mfrow=c(1,2))
acf(d.UNRATE,lag.max=lags,plot=T,lwd=2,xlab="",main="ACF de la variación de la Tasa de desempleo")
pacf(d.UNRATE,lag.max=lags,plot=T,lwd=2,xlab="",main="PACF de la variación de la Tasa de desempleo")

# La gráfica de la variación del Tasa de desempleo, contrario a su version en niveles, evidencia claramente una media contante
# mientras que en la ACF ya no se presenta alta persistencia, por lo que se asume que la serie transformada 
# es estacionaria.

##Si realizamos la prueba de DF sobre la serie diferenciada, podremos constatar que la serie ya sea estacionaria. 
ADF.d.UNRATE <- ur.df(d.UNRATE, type="drift", selectlags = "AIC")
summary(ADF.d.UNRATE) #Rechazamos H0, así que la tasa de crecimiento del IPI es estacionaria en sentido débil.


# Criterios de información para la identificación del modelo: 

#---- Funciones para idenficar modelo ARIMA por criterios de información (metodología manual) ----

# De nuevo, usamos las funciones arma_seleccion_df, arma_min_AIC y arma_min_BIC:
## arma_seleccion_df: función que me ordena en un data.frame todos los posibles grados 
# p y q dado los Criterios de Información AIC y BIC.
## arma_min_AIC: seleccionar el mejor modelo según AIC, es decir, el menor. 
## arma_min_BIC: seleccionar el mejor modelo según BIC, es decir, el menor. 

# Serie en niveles (con d=1):

AR.m = 6; MA.m = 6
mod_d1_UNRATE = arma_seleccion_df(UNRATE, AR.m, MA.m, d = 1, TRUE, "ML")
view(mod_d1_UNRATE)
# Selecciono el mejor modelo según criterios de información cuando d=1
min_aic_UNRATE = arma_min_AIC(mod_d1_UNRATE); min_aic_UNRATE #ARIMA (6,1,6)
min_bic_UNRATE = arma_min_BIC(mod_d1_UNRATE); min_bic_UNRATE #ARIMA (1,1,2)

# Serie diferenciada (con d=0):

mod_d0_UNRATE = arma_seleccion_df(d.UNRATE, AR.m, MA.m, d = 0, TRUE, "ML")
view(mod_d0_UNRATE)
# Selecciono el mejor modelo según criterios de información cuando d=1
min_aic_d.UNRATE = arma_min_AIC(mod_d0_UNRATE); min_aic_d.UNRATE #ARIMA (6,0,6)
min_bic_d.UNRATE = arma_min_BIC(mod_d0_UNRATE); min_bic_d.UNRATE #ARIMA (1,0,2)

# En este caso nos guiamos por el criterio AIC, porque la ACF y la PACF muestran que el valor en el periodo
# actual depende en varios periodos pasados, por lo que conviene escoger un mayor número de rezagos para 
# evitar violar el supuesto de no autocorrelacion, Por tanto seleccionamos el modelo ARIMA(6,0,6) (para la serie diferenciada).

# Por auto.arima
auto.arima(UNRATE, method = "ML")

#---- PASO 2- ESTIMACIÓN tasa de desempleo ----

arima_6.1.6_UNRATE = arima(UNRATE,
                           order = c(6,1,6), include.mean = T, 
                           method = "ML"); summary(arima_6.1.6_UNRATE) # modelamiento ARIMA (6,1,6)

arima_6.0.6_UNRATE = arima(d.UNRATE,
                           order = c(6,0,6), include.mean = T, 
                           method = "ML"); summary(arima_6.0.6_UNRATE) # modelamiento ARIMA (6,1,6)
#Imprimimos el resultado
stargazer(arima_6.0.6_UNRATE, arima_6.1.6_UNRATE, type = "text")


###Para el paso de Validación vamos a mirar cómo se comporta el modelo ARIMA (1,0,2)
arima_1.0.2_UNRATE = arima(d.UNRATE,
                           order = c(1,0,2), include.mean = T, 
                           method = "ML"); summary(arima_1.0.2_UNRATE) # modelamiento ARIMA (6,1,6)


#---- PASO 3- VALIDACIÓN Tasa de Desempleo ----

# El supuesto más importante que se debe validar es que los residuales estimados se comporten como un ruido blanco. 
# Es decir, que la media de los residuales sea cero, la varianza constante y la covarianza sea cero.

# Vamos a realizar el análisis de residuales para cada modelo 

#
# arima_6.1.6_UNRATE
#

## ACF y PACF para el modelo con d = 1
ggAcf(residuals(arima_6.1.6_UNRATE))
ggPacf(residuals(arima_6.1.6_UNRATE)) # la ACF y PACF parece indicar que no hay correlación serial en los residuales del modelo.

# Pruebas formales: 

# 1. Pruebas de correlación serial en los residuales.

#Generalmente la prueba se hace sobre un 1/4 de la muestra, pero también la haremos para otros rezagos. 
lags.test.unrate = length(UNRATE)/4;lags.test.unrate

# Test Box-Pierce para autocorrelación en los residuales
Box.test(residuals(arima_6.1.6_UNRATE),lag=lags.test, type = c("Box-Pierce")) #No rechazo H0, se cumple el supuesto. 
Box.test(residuals(arima_6.1.6_UNRATE),type='Box-Pierce',lag=20) #No rechazo H0, se cumple el supuesto. 
Box.test(residuals(arima_6.1.6_UNRATE),type='Box-Pierce',lag=30) #No rechazo H0, se cumple el supuesto. 
# Test Ljung-Box para autocorrelación en los residuales.
Box.test(residuals(arima_6.1.6_UNRATE),lag=lags.test, type = c("Ljung-Box")) #No rechazo H0, se cumple el supuesto. 
Box.test(residuals(arima_6.1.6_UNRATE),type='Ljung-Box',lag=20) #No rechazo H0, se cumple el supuesto. 
Box.test(residuals(arima_6.1.6_UNRATE),type='Ljung-Box',lag=30) #No rechazo H0, se cumple el supuesto. 

#Para ambas pruebas, no se rechaza la hipótesis nula que asegura el cumplimiento del modelo. Esto significa que el modelo arima escogido 
#para modelar la serie en nivel UNRATE alcanza a capturar toda la estructura de correlación en la serie 
#y eso se refleja en la no presencia de correlación en los residuales.

# 2. Pruebas de Heterocedasticidad en los residuales

# Ahora vamos a mirar el supuesto de heterocedasticidad con un test de efectos ARCH. La prueba nos dice que si los residuales
# son heterocedasticos, los residuales al cuadrado deben estar correlacionados. Hay dos formas de hacer la prueba: Un test 
# Pormenteau y un Test tipo multiplicadores de Lagrange.

arch_unrate6.1.6 <-arch.test(arima_6.1.6_UNRATE, output=TRUE)#Rechazo H0 en ambas pruebas, así que los residuales son heterocedásticos.
# La serie no es estacionaria en varianza, por lo que la varianza cambia a lo largo de la serie como se observa si se gráfica la serie.

# 3. Pruebas de normalidad en los residuales

#QQ-PLOT 
par(mfrow=c(1,1))
Residuales_unrate6.1.6=arima_6.1.6_UNRATE$residuals
qqPlot(Residuales_unrate6.1.6)

#Prueba Jarque-Bera
jarque.bera.test(residuals(arima_6.1.6_UNRATE)) #Se rechaza H0, no hay normalidad. 

#
# arima_1.0.2_UNRATE 
#

## ACF y PACF para el modelo con d = 0
ggAcf(residuals(arima_1.0.2_UNRATE))
ggPacf(residuals(arima_1.0.2_UNRATE)) # la ACF y PACF parece indicar que no hay correlación serial en los residuales del modelo 

# Pruebas formales: 

# 1. Pruebas de correlación serial en los residuales

#Generalmente la prueba se hace sobre un 1/4 de la muestra, pero también la haremos para otros rezagos. 
lags.test.unrate = length(UNRATE)/4;lags.test.unrate

# Test Box-Pierce para autocorrelación en los residuales
Box.test(residuals(arima_1.0.2_UNRATE),lag=lags.test, type = c("Box-Pierce")) #Rechazo H0, no se cumple el supuesto. 
Box.test(residuals(arima_1.0.2_UNRATE),type='Box-Pierce',lag=20) #No Rechazo H0, se cumple el supuesto. 
Box.test(residuals(arima_1.0.2_UNRATE),type='Box-Pierce',lag=30) #Rechazo H0, no se cumple el supuesto.
# Test Ljung-Box para autocorrelación en los residuales.
Box.test(residuals(arima_1.0.2_UNRATE),lag=lags.test, type = c("Ljung-Box")) #Rechazo H0, no se cumple el supuesto.
Box.test(residuals(arima_1.0.2_UNRATE),type='Ljung-Box',lag=20) #No Rechazo H0, se cumple el supuesto.
Box.test(residuals(arima_1.0.2_UNRATE),type='Ljung-Box',lag=30) #Rechazo H0, no se cumple el supuesto.

# 2. Pruebas de Heterocedasticidad en los residuales

# Ahora vamos a mirar el supuesto de heterocedasticidad con un test de efectos ARCH. La prueba nos dice que si los residuales
# son heterocedasticos, los residuales al cuadrado deben estar correlacionados. Hay dos formas de hacer la prueba: Un test 
# Pormenteau y un Test tipo multiplicadores de Lagrange.

arch_unrate.1.0.2 <-arch.test(arima_1.0.2_UNRATE, output=TRUE)#Rechazo H0 en ambas pruebas, así que los residuales son heterocedásticos.
# El resultado de la prueba da que la serie no es estacionaria en varianza, por lo que la varianza
# cambia a lo largo de la serie como se observa si se gráfica la serie.

# 3. Pruebas de normalidad en los residuales

#QQ-PLOT 
par(mfrow=c(1,1))
Residuales_unrate1.0.2=arima_1.0.2_UNRATE$residuals
qqPlot(Residuales_unrate1.0.2)

#Prueba Jarque-Bera
jarque.bera.test(residuals(arima_1.0.2_UNRATE)) #Se rechaza H0, no hay normalidad. 

#En resúmen, en el caso del modelo arima_6.1.6 tenemos que se cumple el supuesto de no correlación de los residuales
#independientemente de la cantidad de rezagos que se pongan. No se cumple ni la homocedasticidad ni la normalidad de 
#los mismos. Es importante destacar que el incumplimicento de este último supuesto (normalidad) no
#afecta los pronósticos (siguen siendo consistentes), pero sí incide en los intervalos de confianza de los mismos
#(en general, afecta la inferencia estadística realizada sobre los coeficientes de la serie).

#En el caso de la serie arima1.0.2 los resultados no son concluyentes en cuando a la no correlación de los residuales. 
#De igual manera, no se cumplen los supuestos de homocedasticidad y la normalidad. 


#---- PASO 4- PRONÓSTICO UNRATE ----

# Pronóstico pasos adelante 

# Nota: Los intervalos de confianza que aparecen en dichos pronósticos no son buenos, dado que no se cumple 
# el supuesto de normalidad en los residuales.

## Utilizando el comando forecast del paquete forecast 
forecast.l.unrate <- forecast(arima_6.1.6_UNRATE, lead = 12, alpha = 0.05,output = T)   # Pronóstico 12 pasos adelante.
forecast.l.unrate

## Utilizando el comando sarima.for del paquete astsa
sarima.for(UNRATE, n.ahead = 12, p = 6, d = 1, q = 6)

#Ahora vamos a ver el ajuste dentro de muestra

## Para la serie UNRATE
fit_unrate <- UNRATE - residuals(arima_6.1.6_UNRATE)
## Para la serie d.UNRATE
fit_unrate1 <- d.UNRATE - residuals(arima_6.0.6_UNRATE)

#Predicción sobre la muestra
x11()
plot.ts(UNRATE,type="l",main="Serie en nivel ajustada VS serie en nivel observada",lwd=2)
points(fit_unrate,col="blue",lwd=2, type = "l")
legend("topleft",c("observada", "estimada"), col=c("black","blue"),lty=1,lwd=2)

x11()
plot.ts(d.UNRATE,type="l",main="Tasa de crecimiento ajustada VS Tasa de crecimeinto observada",lwd=2)
points(fit_unrate1,col="green",lwd=2, type = "l")
legend("topleft",c("observada", "estimada"), col=c("black","darkgreen"),lty=1,lwd=2)


#
# Notas finales
#

# Como pudieron notar los modelos ARMA son modelos que están diseñados para modelar series estacinoarias en covarianza.
## Eso implica que uno debería utilizar un modelo ARMA cuando las series se comportan con media constante, varianza constante 
## y autocorrelación que depende solo de la distancia temporal entre las observaciones.
## Para corroborar que una serie es estacionaria se podría verificar que los residuales del modelo en efecto se comporten como
## ruido blanco. 

#
# Notas sobre volatilidad
#

# Como lo muestra la gráfica: 
plot(diff(UNRATE_xts), main = "Variación de la Tasa de Desempleo de Estados Unidos (1960-2013)", ylab  = "variación tasa de desempleo")

#Obsevamos la misma situación de clusters de volatilidad que con la serie anterior de  la tasa de crecimeiento del IPI.
# Esto significa que  no hay una varianza constante a lo largo de la serie, sino que pareciera que en determinados periodos de tiempo 
#hay un tipo de volatilidad y en otro periodo de tiempo dicha volatilidad cambia.

# Dado que los modelos ARMA están diseñados para series con varianza constante se requiere de otro tipo de modelos capaces de capturar esos
# esos clusters de volatilidad. Para ello, se emplean modelos capaces de capturar modelar la varianza variable en el tiempo del proceso generador de datos
# Dichos modelos son: 
### arch: Extensión del modelo AR para modelar series de tiempo con clusters de volatilidad
### garch: Extensión del modelo ARMA para modelar serie de tiempo con clusters de volatilidad 




